#!/usr/bin/ruby -w

# written by Henning Fehrmann <henning.fehrmann@ligo.org> and
# Carsten Aulbert <carsten.aulbert@ligo.org>
# and some addition by Satya Mohapatra <patra@mit.edu>
# December 2014
# Query all local schedd for jobs finished/removed within the past day
# and aggregate this information into simply daily text file

# to cut down on run duration, the following HISTORY related settings
# for condor are encouraged to be used:
#
# ENABLE_HISTORY_ROTATION=TRUE
# MAX_HISTORY_LOG=1000000000
# MAX_HISTORY_ROTATIONS=7
# ROTATE_HISTORY_DAILY=True
# HISTORY_HELPER_MAX_HISTORY=999999999

require 'json'
require 'getoptlong'

# find out Unix epoch range for day preceeding now
now = Time.now

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--verbose', '-v', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--cluster', '-c', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--schedulers', '-s', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--utc', '-u', GetoptLong::REQUIRED_ARGUMENT ]
)

verbose = false
cluster = ''
schedulers = ''

opts.each do |opt,arg|
  case opt
  when '--help'
    puts <<-EOF
#{$0} [-h|--help] [-v|--verbose] [-u|--utc] <-c|--cluster>

-h, --help:       show this help message
-v, --verbose:    Be more verbose about what is happening
                  note, prepending # to ensure it does not mangle output
-c, --cluster:    Mandatory argument to depict which cluster the accounting
                  information belongs to - is also part of output
-s, --schedulers: Optional argument to explicitly list schedulers to query.
                  Defaults to discovery via HTCondor pool.
-u, --utc:     Run query for specified UTC date (YYYY-MM-DD), not UTC yesterday
EOF
    exit 0
  when '--verbose'
    verbose = 42
  when '--cluster'
    cluster = arg
  when '--schedulers'
    schedulers = arg
  when '--utc'
    begin
      # interpret the utc argument as the date to report on so redefine
      # "now" to the conclusion of that day
      tmp = arg.split("-")
      now = Time.utc(tmp[0], tmp[1], tmp[2]) + 86400
    rescue
      STDERR.puts "Time does not like #{arg} format (should be YYYY-MM-DD)"
      exit 1
    end
  end
end

# bail out unless cluster is set
if cluster.empty?
  # fall back to previous implementation where cluster = ARGV[0]
  if ARGV[0].nil?
    STDERR.puts "Cluster name unset, please specify with --cluster"
    exit 1
  else
    cluster = ARGV[0]
  end
end


# set stop time according to "now" as potentially redefined by --utc argument
a = now.gmtime.to_a
stop_time = Time.utc(a[5],a[4],a[3],0,0,0)
epoch_stop = stop_time.to_i

# epoch second of yesterday's UTC day start
a = (now.gmtime - 86400).to_a
start_time = Time.utc(a[5],a[4],a[3],0,0,0)
epoch_start = start_time.to_i

# ISO string for today's UTC day
date_start = (now.gmtime - 86400).strftime("%F")

if verbose
  puts "# Now: #{now.localtime} | #{now.gmtime}"
  puts "# Will restrict search between epoch #{epoch_start}s and #{epoch_stop}s"
  puts "# which translates to #{start_time.localtime} | #{start_time.gmtime}"
  puts "#                 and #{stop_time.localtime} | #{stop_time.gmtime}."
end

# querying pool status requires two steps
# (1) get list of all known schedd
#     done by 'condor_status -schedd -format "%s\n" Machine'
# (2) iterate over all schedd in pool requesting history information
#     done by lengthy call to condor_history (see below)
#

# we worry about the edge case that condor_status does not return anything
# as we are called only once a day, try it 3 times with 10s gaps in-between
if schedulers.empty?
  puts "# will now try auto-discovery of submit hosts, will take about 25s" if verbose
  hosts = []
  3.times do
    ret = `/usr/bin/condor_status -schedd -format \"%s\\n\" Machine`
    hosts << ret.split("\n") unless ret.empty?
    sleep 10
  end
else
  hosts = schedulers.split(/[, ]/).map(&:strip).reject(&:empty?)
end

# make host entries unique
hosts = hosts.flatten.uniq

# exit if still empty
if hosts.empty?
  STDERR.puts "condor_status did not return any schedd names, exiting"
  exit 1
end

if verbose
  puts "# Will now query the following discovered submit hosts"
  hosts.each { |h|
    puts "# #{h}"
  }
end

history = []
hosts.each do |machine|
  history << Thread.new(machine) { |m|
    Thread.current[:t_start] = Time.now
    puts "# Thread for host #{m.chomp} starts" if verbose
    # constructing command first to evade excessive escapism
    cmd = '/usr/bin/condor_history -name ' +  m.chomp +
          %q[ -since "JobFinishedHookDone < ] + epoch_start.to_s + %q["] +
          %q[ -constraint "JobUniverse != 7 && EnteredCurrentStatus <= ] + epoch_stop.to_s + %q["] +
          %q[ -format "{ \"Owner\" : \"%s\", " Owner] +
          %q[ -format "\"LigoSearchUser\" : \"%s\", " LigoSearchUser] +
          %q[ -format "\"LigoSearchTag\" : \"%s\", " LigoSearchTag] +
          %q[ -format "\"RequestCpus\" : \"%s\", " RequestCpus] +
          %q[ -format "\"MaxHosts\" : \"%s\", " MaxHosts] +
          %q[ -format "\"RemoteWallClocktime\" : \"%.0f\" }\n" RemoteWallClocktime]

    Thread.current[:output] = `#{cmd} 2>/dev/null`
    Thread.current[:err] = "Query error for #{m.chomp}, either no finished jobs or time-out" unless $?.to_i == 0
    Thread.current[:t_end] = Time.now

    run_time = Thread.current[:t_end] - Thread.current[:t_start]
    puts "# Thread for host #{m.chomp} ended after #{run_time.to_i}s" if verbose
  }
end

# wait for threads to end
history.each do |h|
  h.join
end

# finally generate accounting summary
accounting = Hash.new

history.each do |h|

  STDERR.puts "#{h[:err]}" if h.key?(:err)

  h[:output].each_line do |line|
    job = JSON.parse(line)
    owner = ""
    tag = ""

    # owner is set by "LigoSearchUser" or "Owner" or default
    if job.key?("LigoSearchUser")
      owner = job["LigoSearchUser"]
    elsif job.key?("Owner")
      owner = job["Owner"]
    else
      owner = "UNKNOWN"
    end

    # tar is set by "LigoSearchTag" or "AccountingGroup" or default
    if job.key?("LigoSearchTag")
      tag = job["LigoSearchTag"]
    elsif job.key?("AccountingGroup")
      tag = job["AccountingGroup"]
    else
      tag = "UNDEFINED"
    end

    # remove owner from end of tag if present, this could break down
    # in the unlikely event of owner being legitimately the last bit
    # of tag
    tag.sub!(/\.#{owner}$/, "")

    # add to global accounting information
    accounting[owner] ||= Hash.new
    accounting[owner][tag] = 0 unless accounting[owner].key?(tag)
    cpu_weight = ( job.key?("RequestCpus") ? job["RequestCpus"] : 1).to_f *
      ( job.key?("MaxHosts") ? job["MaxHosts"] : 1).to_f
    accounting[owner][tag] += cpu_weight * job["RemoteWallClocktime"].to_f / 3600.0
  end
end

accounting.each_key do |owner|
  accounting[owner].each_pair do |key,val|
    puts "#{owner} #{key} #{val.ceil} #{date_start} #{cluster}"
  end
end
